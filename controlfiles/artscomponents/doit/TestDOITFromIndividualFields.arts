#DEFINITIONS:  -*-sh-*-

#This control file demonstrates how to do a scattering (here: DOIT) calculation
# with all atmospheric fields (clearsky and cloud/precip) taken from model data,
# and particle number density fields calculated from these model atmospheric
# fields.
#The case applies data equivalent to the first scenario used in TestDoitBatch
# (folder doitbatch). Therefore, results are checked against the TestDoitBatch
# reference results for that scenario. Also, the absorption lookup table from
# doitbatch is applied.
#
# Author: Jana Mendrok
# 

Arts2 {

INCLUDE "general/general.arts"
INCLUDE "general/continua.arts"
INCLUDE "general/agendas.arts"
INCLUDE "general/agendasDOIT.arts"
INCLUDE "general/planet_earth.arts"



# 1. General Settings---------------------------------------------
#----------------------------------------------------------------- 

# Agenda for scalar gas absorption calculation
Copy(abs_xsec_agenda, abs_xsec_agenda__noCIA)

# (standard) emission calculation
Copy( iy_main_agenda, iy_main_agenda__Emission )

# cosmic background radiation
Copy( iy_space_agenda, iy_space_agenda__CosmicBackground )

# standard surface agenda (i.e., make use of surface_rtprop_agenda)
Copy( iy_surface_agenda, iy_surface_agenda__UseSurfaceRtprop )

# Planck as blackbody radiation
Copy( blackbody_radiation_agenda, blackbody_radiation_agenda__Planck )

# sensor-only path
Copy( ppath_agenda, ppath_agenda__FollowSensorLosPath )

# no refraction
Copy( ppath_step_agenda, ppath_step_agenda__GeometricPath )


# Set out put file format
#------------------------
output_file_formatSetAscii

# Define f_grid
#--------------
VectorSet( f_grid, [9.0e10, 19.0e10])

#Set stokes dim
#--------------
IndexSet (stokes_dim, 1)

#def of atmosphere
#-----------------
AtmosphereSet1D

#No jacobian calculations
#-----------------
jacobianOff

# Modifiy the maximum propagation step, from the default(10.e3)
# to 250 m:---------------------------------------------------
NumericSet( ppath_lmax, 250 )



# 2. Sensor----------------------------------------------------------
#--------------------------------------------------------------------

# Line of sight
MatrixSet( sensor_los,  [131; 179])
# Sensor position
nrowsGet( nrows, sensor_los )
ncolsGet( ncols, sensor_los )
MatrixSetConstant( sensor_pos, nrows, ncols, 850e3 )
# No sensor characteristics are specified
sensorOff



# 3. Prepare atmospheric (clearsky) data------------------------------
#---------------------------------------------------------------------
abs_speciesSet( species=[ "H2O-PWR98",
                          "O3",
                          "O2-PWR93",
                          "N2-SelfContStandardType"
                        ] )

# Atmospheric profiles
AtmRawRead( basename="testdata/chevallierl91_all_extract_wbackground_scenario0" )
p_gridFromZRaw
AtmFieldsCalc
atmfields_checkedCalc



# 4. Absorption-------------------------------------------------
#---------------------------------------------------------------

# Creation of abs_lookup table
#-----------------------------
  # ATTENTION: The abs_lookup table used with this test control file was 
  #generated by the following code. It is adapted to the specified abs_species,
  #to the specified atmospheric data and frequencies ranging from 80e9 Hz to 
  #200e9 Hz. If changes to these inputs are applied the abs_lookup table must 
  #be recalculated.

  # Read HITRAN catalog (needed for O3):
  #abs_linesReadFromHitran( abs_lines,
  #                         "/storage3/data/catalogue/hitran/hitran2012/HITRAN2012.par",
  #                         80e9,
  #                         200e9 )

  #abs_lines_per_speciesCreateFromLines

  #abs_lookupSetup

  #abs_xsec_agenda_checkedCalc
  #abs_lookupCalc

  #WriteXML( in=abs_lookup )

# Reading of abs_lookup table
#----------------------------
ReadXML( abs_lookup, "../doitbatch/abs_lookupBatch.xml" )

# Check if lookup table is fitting input
abs_lookupAdapt

# absorption from LUT
Copy( propmat_clearsky_agenda, propmat_clearsky_agenda__LookUpTable )
propmat_clearsky_agenda_checkedCalc




# 5. Surface properties-----------------------------------------
#---------------------------------------------------------------
# Set surface reflectivity (=1-emissivity)
# corresponds to emissivity=0.75
VectorSetConstant( surface_scalar_reflectivity, 1, 0.25 )

Copy( surface_rtprop_agenda,
      surface_rtprop_agenda__Specular_NoPol_ReflFix_SurfTFromt_surface )

# Get some surface properties from corresponding atmospheric fields
Extract( z_surface, z_field, 0 )
Extract( t_surface, t_field, 0 )



# 6. Specification of cloud----------------------------------------------
# -----------------------------------------------------------------------


# Definition of particle species
#--------------------------------
scat_speciesSet(scat_species, [
                "LWC-H98_STCO-0.1-2000",
                "IWC-MH97-0.1-2000",
                "RR-MP48-*-*"
])

# Preparing the cloud field data
#-------------------------------
GriddedField3Create( gf3 )
ArrayOfGriddedField3Create( mass_density_raw )
ArrayOfGriddedField3Create( mass_flux_raw )

#we are going to use scattering species defined in terms of mass_density and
# mass_flux in parallel. hence, we need to provide data containers for both. and
# need to fill the one not used for the specific scattering species with empty
# profiles.

#liquid water content: mass_density. empty mass_flux placeholder.
ReadXML( gf3, "testdata/chevallierl91_all_extract_wbackground_scenario0.LWC.mass_density.xml" )
Append( mass_density_raw, gf3 )
ReadXML( gf3, "testdata/empty_profile.xml" )
Append( mass_flux_raw, gf3 )

#ice water content: mass_density. empty mass_flux placeholder.
ReadXML( gf3, "testdata/chevallierl91_all_extract_wbackground_scenario0.IWC.mass_density.xml" )
Append( mass_density_raw, gf3 )
ReadXML( gf3, "testdata/empty_profile.xml" )
Append( mass_flux_raw, gf3 )

#rain rate: mass_flux. empty mass_density placeholder.
ReadXML( gf3, "testdata/empty_profile.xml" )
Append( mass_density_raw, gf3 )
ReadXML( gf3, "testdata/chevallierl91_all_extract_wbackground_scenario0.RR.mass_flux.xml" )
Append( mass_flux_raw, gf3 )

GriddedFieldPRegrid( out=mass_density_raw, in=mass_density_raw, zeropadding=1 )
FieldFromGriddedField( out=scat_species_mass_density_field, in=mass_density_raw )
GriddedFieldPRegrid( out=mass_flux_raw, in=mass_flux_raw, zeropadding=1 )
FieldFromGriddedField( out=scat_species_mass_flux_field, in=mass_flux_raw )

#and we need to initialize number_density as empty
Touch( scat_species_number_density_field )

# Unrealistic (small) values in massdensity_field will be set to zero
scat_species_fieldCleanup (scat_species_mass_density_field,
                           scat_species_mass_density_field,
                           1e-15)
scat_species_fieldCleanup (scat_species_mass_flux_field,
                           scat_species_mass_flux_field,
                           1e-15)


# Read SingleScatteringData and ScatteringMetaData
#-------------------------------------------------
ArrayOfStringCreate( scat_data_files )
#ReadXML( scat_data_files, "testdata/SingleScatteringFile_H2Oliquid.xml" )
ScatteringParticleTypeAndMetaRead ( scat_data_files=[
 "testdata/scatData/MieAtmlab_Liquid_0.4um.xml.gz",
 "testdata/scatData/MieAtmlab_Liquid_0.9um.xml.gz",
 "testdata/scatData/MieAtmlab_Liquid_32.4um.xml.gz",
 "testdata/scatData/MieAtmlab_Liquid_72.9um.xml.gz"] )
ReadXML( scat_data_files, "testdata/SingleScatteringFile_H2Oice.xml" )
ScatteringParticleTypeAndMetaRead ( scat_data_files=scat_data_files )
ReadXML( scat_data_files, "testdata/SingleScatteringFile_H2Oliquid.xml" )
ScatteringParticleTypeAndMetaRead ( scat_data_files=scat_data_files )

# Selection/filerting of particles according to *scat_species*
#------------------------------------------------------------
ScatteringParticlesSelect
scat_dataCheck


# Set cloudbox limits 
# ---------------------------------------------------------------------
cloudboxSetAutomatically

# Particle Number Density field calculation
# -----------------------------------------
pnd_fieldCalcFromscat_speciesFields



# 7. DOIT settings-------------------------------------------------------
#------------------------------------------------------------------------

# Check the include files to see the setting of Agendas and if needed,
# overwrite them by re-setting the agendas here.------------------------


# Select zenith angle interpolation method ('linear' or 'polynomial'):
# --------------------------------------------------------------------
# If "polynomial" is selected one has to use an optimized grid. Please     
# use *doit_za_grid_optCalc* to optimize the grid.
doit_za_interpSet( doit_za_interp, atmosphere_dim, "linear" )

# Sets the angular grids for DOIT calculation     
# --------------------------------------------------------------------
# For down- and up-looking geometries. 
DoitAngularGridsSet( doit_za_grid_size, scat_aa_grid, scat_za_grid,
      19, 37, "" )

AgendaSet( doit_conv_test_agenda ){
  # Give limits for all Stokes components in BT:
  doit_conv_flagAbsBT( epsilon=[0.1],
                       max_iterations=100,
                       nonconv_return_nan=1)
}



# 8. The RT calculation--------------------------------------------------
#------------------------------------------------------------------------

# Consistency checks
atmfields_checkedCalc
atmgeom_checkedCalc
cloudbox_checkedCalc  
sensor_checkedCalc

# Initialize Doit variables
DoitInit

# Calculate incoming radiation field on cloudbox boundaries
DoitGetIncoming

# Set first guess field
doit_i_fieldSetClearsky

# Executes doit_mono_agenda for all frequencies
DoitCalc

# Here we choose our *y* output unit 
StringSet( iy_unit, "PlanckBT" )

# Calculate complete measurement vector 
yCalc

#WriteXML( output_file_format, y )

# Verify results
ArrayOfVectorCreate( ybatch_ref )
ReadXML( ybatch_ref, "../doitbatch/TestDOITBatch.ybatch.ref.xml" )
VectorCreate( y_ref )
Extract( y_ref, ybatch_ref, 0 )

Compare( y, y_ref, 0.01,
         "Total BT should be close to the reference values")

#==================stop==========================

} # End of Main
