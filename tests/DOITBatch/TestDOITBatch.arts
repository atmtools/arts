#DEFINITIONS:  -*-sh-*-

#This control file handles a DOIT batch calculation with ARTS internal
#pnd_field calculations. Four atmospheres from Chevallier91L
#data are used for atmospheric input. No sensor characteristics 
#are applied. Only two frequencies and two line of sights are used,
#for calculation time reasons.

Arts2 {

INCLUDE "general.arts"
INCLUDE "continua.arts"
INCLUDE "agendasDOIT.arts"

# 1.General Settings:---------------------------------------------
#----------------------------------------------------------------- 

# Set out put file format
#------------------------
output_file_formatSetAscii

# Define f_grid
#--------------
VectorSet( f_grid, [9.0e10, 19.0e10])
#ReadXML(f_grid, "f_grid.xml")
#VectorNLinSpace (f_grid, 10, 120e9, 300e9)
#WriteXML (output_file_format, f_grid, "f_grid.xml")

#Set stokes dim
#--------------
IndexSet (stokes_dim, 1)

#def of atmosphere
#-----------------
IndexSet (atmosphere_dim, 1)

# Modifiy the maximum propagation step, from the default(10.e3)
# to 250 m:---------------------------------------------------
NumericSet( ppath_lmax, 250 )

# Surface properties
#-------------------
# Set surface reflectivity (=1-emissivity)
# corresponds to emissivity=0.75
VectorSetConstant( surface_scalar_reflectivity, 1, 0.25 )

AgendaSet( surface_prop_agenda ){
  Ignore(rte_pos)
  Ignore(rte_gp_p)
# Ignore(rte_los)
  InterpSurfaceFieldToRteGps( surface_skin_t, atmosphere_dim, 
                              rte_gp_lat, rte_gp_lon, t_surface )
  surfaceFlatReflectivity( surface_los, surface_rmatrix, surface_emission,
	                   f_grid, stokes_dim, atmosphere_dim, rte_los,
	                   surface_skin_t, surface_scalar_reflectivity )
# surfaceBlackbody
} 


# 2. Sensor:---------------------------------------------------------
#--------------------------------------------------------------------

# Definition of sensor position and LOS
# ------------------------------------
# Line of sight
MatrixSet( sensor_los,  [131; 179])
# Sensor position
nrowsGet( nrows, sensor_los )
ncolsGet( ncols, sensor_los )
MatrixSetConstant( sensor_pos, nrows, ncols, 850e3 )
# No sensor characteristics are specified
sensorOff


# 3. Read chevallier atmospheric profiles for batch calc--------------
#---------------------------------------------------------------------
ArrayOfMatrixCreate( arrayofmatrix_1 )
#read data to ArrayOfMatrix
ReadXML( arrayofmatrix_1, "chevallierl91_all_extract.xml" )


# Convert to batch_atm_fields_compact AND batch_atm_fields_compact_all
# -----------------------------------------------------------------------
# The values taken for O2 and N2 are from Wallace&Hobbs, 2nd edition.
batch_atm_fields_compactFromArrayOfMatrixChevalAll(
   batch_atm_fields_compact,
   batch_atm_fields_compact_all,
   atmosphere_dim,
   arrayofmatrix_1,
   ["T", "z", "LWC", "IWC", "Rain", "Snow", "H2O", "O3"],
   ["O2", "N2"],
   [0.2095, 0.7808]
)
# WriteXML("output_file_format", batch_atm_fields_compact_all)

Delete( arrayofmatrix_1 )

# 4. Absorption-------------------------------------------------
#---------------------------------------------------------------

SpeciesSet( abs_species, [ "H2O-PWR98",
                           "O3",
                           "O2-PWR93",
                           "N2-SelfContStandardType" ] )

# Creation of abs_lookup table
#-----------------------------
  # ATTENTION: The abs_lookup table used with this test control file was 
  #generated by the following code. It is adapted to the specified abs_species,
  #to the specified atmospheric data and frequencies ranging from 80e9 Hz to 
  #200e9 Hz. If changes to these inputs are applied the abs_lookup table must 
  #be recalculated.

  # Read HITRAN catalog (needed for O3):
  #abs_linesReadFromHitran2004( abs_lines,
  #                             "/storage3/data/catalogue/hitran/hitran2004/HITRAN04.par",
  #                             80e9,
  #                             200e9 )

  #abs_lines_per_speciesCreateFromLines

  #abs_lookupSetupBatch   	

  #abs_lookupCreate

  #WriteXML("ascii", abs_lookup, "abs_lookupBatch.xml")

# Reading of abs_lookup table
#----------------------------
ReadXML( abs_lookup, "abs_lookupBatch.xml" )

# Check if lookup table is fitting input
abs_lookupAdapt

# Set abs_scalar_gas_agenda to use lookup table
AgendaSet( abs_scalar_gas_agenda ){ 
  abs_scalar_gasExtractFromLookup 
}


# 6.Specification of cloud-----------------------------------------------
# -----------------------------------------------------------------------

# Read SingelScatteringData and ScatteringMetaData
#-------------------------------------------------
ScatteringParticleTypeAndMetaRead (scat_data_raw, scat_data_meta_array, f_grid, 
    "SingleScatteringFile.xml",
    "ScatteringMetaFile.xml")

# Definition of particle species
#--------------------------------
ParticleSpeciesSet(part_species, ["IWC-MH97-0.1-2000", "LWC-liquid-0.1-2000"])

# Selection/filerting of particles according to *part_species*
#------------------------------------------------------------
ScatteringParticlesSelect


# 7.AGENDAS--------------------------------------------------------------
#------------------------------------------------------------------------

# Check the include files to see the setting of Agendas and if needed,
# overwrite them by re-setting the agendas here.------------------------


# This agenda is already specified in general.arts
AgendaSet( iy_clearsky_agenda ){
#  radiative transfer calculations with emission
   iyEmissionStandardClearsky
}

# Select zenith angle interpolation method ('linear' or 'polynomial'):
# --------------------------------------------------------------------
# If "polynomial" is selected one has to use an optimized grid. Please     
# use *doit_za_grid_optCalc* to optimize the grid.
doit_za_interpSet( doit_za_interp, atmosphere_dim, "linear" )

# Sets the angular grids for DOIT calculation     
# --------------------------------------------------------------------
# For down- and up-looking geometries. 
DoitAngularGridsSet( doit_za_grid_size, scat_aa_grid, scat_za_grid,
      19, 10, "" )

# For limb calculations it is very important to have a finer zenith angle
# grid resolution about 90 degrees sza.
# The finer grid will be used for the RT calculations, while the scattering
# integral is still solved for the original sza grid.
# Make sure to set the path to "doit_za_grid_opt.xml" 
#   DoitAngularGridsSet( doit_za_grid_size, scat_aa_grid, scat_za_grid,
#                     19, 10, "PATH/doit_za_grid_opt.xml" )


# Batch Agenda-----------------------------------------------------------
#------------------------------------------------------------------------
AgendaSet( ybatch_calc_agenda ){
  
  # Extract the atmospheric profiles for current atmosphere:
  Extract(
    atm_fields_compact_all, 
    batch_atm_fields_compact_all, 
    ybatch_index
  )

  # Split up *atm_fields_compact_all* to
  # generate p_grid, t_field, z_field, massdensity_field, vmr_field:
  AtmFieldsFromCompactChevalAll

  # Unrealistic (small) values in massdensity_field will be set to zero
  Massdensity_cleanup
  #Massdensity_cleanup(massdensity_field, 1e-15)

  # Get some surface properties from corresponding atmospheric fields
  Extract( z_surface, z_field, 0 )
  Extract( t_surface, t_field, 0 )

  # Set cloudbox limits automatically from scattering particle profiles 
  #(pressure units)
  # ---------------------------------------------------------------------
  cloudboxSetAutomatically
  # cloudboxSetAutomatically( cloudbox_on, cloudbox_limits, atmosphere_dim, 
  #    part_species, p_grid, lat_grid, lon_grid, massdensity_field, -1 )
  #
  # Alternative: set cloudbox manually
  # In this case the extent of the cloudbox should cover almost the 
  # whole troposphere, to make sure, that all scattering particles of all 
  # atmospheres are encompassed by it.
  #  cloudboxSetManually(cloudbox_on, cloudbox_limits, atmosphere_dim, 
  #      p_grid, lat_grid, lon_grid, 101300, 5000, 0, 0, 0, 0 )

  # Particle Number Density calculations
  # ------------------------------------
  pnd_fieldSetup
  #pnd_fieldSetup( pnd_field, atmosphere_dim, cloudbox_on, cloudbox_limits, 
  #    massdensity_field, t_field, scat_data_meta_array, part_species, 
  #    scat_data_nelem )
  
  #Write indexed pnd_fields to sub-folder for each atmosphere
  #WriteXMLIndexed (output_file_format, ybatch_index, pnd_field, 
  #    "./pnd_fields/pnd_f")

  # Calculate incoming radiation field on cloudbox boundaries
  CloudboxGetIncoming

  # Initialize Doit variables
  DoitInit

  # Executes doit_mono_agenda for all frequencies
  ScatteringDoit

  # Consistency checks
  basics_checkedCalc
  cloudbox_checkedCalc  

  # Calculate complete measurement vector 
  yCalc
}

# Here we choose our *y* output unit 
StringSet( y_unit, "PlanckBT" )

# Set number of batch cases:
nelemGet( ybatch_n, batch_atm_fields_compact )
#IndexSet(ybatch_start, 0)
#IndexSet(ybatch_n, 4)

#===========start batch calc=====================
# Execute the batch calculations:
# This test control file can be run multi-threaded, since it was approved
# that none of the jobs fails. 
# If settings are changed, especially if the input atmospheres are altered 
# or exchanged, the robust option in *ybatchCalc* should be used.
ybatchCalc

# Call *ybatchCalc* robust:
# Set robust flag to 1. If one individual job fails, ARTS will continue
# with the next batch job.
# ybatchCalc(ybatch, ybatch_jacobians, ybatch_start, ybatch_n, 
#    ybatch_calc_agenda, 1 )

WriteXML( output_file_format, ybatch)



#==================stop==========================

} # End of Main
