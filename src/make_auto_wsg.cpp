#include <algorithm>
#include <format>
#include <fstream>
#include <iostream>
#include <utility>
#include <vector>

#include "workspace_agendas.h"
#include "workspace_groups.h"
#include "workspace_variables.h"

const auto& data = internal_workspace_groups();

std::vector<std::pair<std::string, std::vector<std::string>>> files() {
  std::vector<std::pair<std::string, std::vector<std::string>>> files;

  for (const auto& [group_name, group] : data) {
    auto ptr = std::find_if(files.begin(),
                            files.end(),
                            [f = group.file](auto& p) { return f == p.first; });
    if (ptr == files.end()) {
      files.emplace_back(group.file, std::vector<std::string>{group_name});
    } else {
      ptr->second.push_back(group_name);
    }
  }

  std::sort(files.begin(), files.end(), [](auto& a, auto& b) {
    return a.first < b.first;
  });

  for (auto& [file, groups] : files) {
    std::sort(groups.begin(), groups.end());
  }

  // auto_wsa_operators.h must be last as it is auto-generated and need all the other types:
  auto ptr = std::find_if(files.begin(), files.end(), [](auto& p) {
    return p.first == "auto_agenda_operators.h";
  });

  if (ptr == files.end())
    throw std::logic_error("Missing auto_agenda_operators.h");

  std::rotate(ptr, ptr + 1, files.end());

  return files;
}

std::vector<std::string> groups() {
  std::vector<std::string> groups;
  groups.reserve(data.size());

  for (const auto& [group_name, group] : data) {
    groups.push_back(group_name);
  }

  std::sort(groups.begin(), groups.end());

  return groups;
}

void header(std::ostream& os) {
  os << R"--(#pragma once

//! auto-generated by make_auto_wsg.cpp

#include <memory>
#include <iosfwd>

)--";

  for (const auto& [file, groups] : files()) {
    os << "// ";
    for (const auto& group : groups) {
      os << group << ", ";
    }
    os << std::format("\n#include <{0}>\n\n", file);
  }

  os << "template <typename T>\nconcept WorkspaceGroup = false";
  for (auto& group : groups()) {
    os << std::format("\n  || std::is_same_v<T, {0}>", group);
  }
  os << "\n;\n\n"
        "template <typename T>\nconcept QualifiedWorkspaceGroup "
        "= WorkspaceGroup<std::remove_cvref_t<T>>;\n\n";

  os << R"(
template <typename T>
concept WorkspaceGroupIsDefaultConstructible = requires(T) {
  T{};
};

template <typename T>
concept WorkspaceGroupIsCopyable = requires(T a) {
  T{a};
};
)";

  os << '\n';
  for (auto& group : groups()) {
    os << std::format(R"(
void xml_read_from_stream(std::istream &, {0}&, bifstream *);
void xml_write_to_stream(std::ostream &, const {0}&, bofstream *, const String &);
)",
                      group);
  }

  os << R"(
template <typename T> struct WorkspaceGroupInfo {
  static constexpr std::string_view name = "<Unknown>";
  static constexpr std::string_view file = "<Unknown>";
  static std::string_view desc();
  static constexpr bool map_or_vector = false;
  static constexpr bool value_type = false;
};

)";

  std::size_t index = 0;
  for (auto& group : groups()) {
    os << std::format(R"(
template <> struct WorkspaceGroupInfo<{0}> {{
  static constexpr std::string_view name = "{0}";
  static constexpr std::string_view file = "{1}";
  static constexpr std::size_t index     =  {5};
  static constexpr bool map_or_vector     = {3};
  static constexpr bool value_type        = {4};
  static std::string_view desc();
}};
)",
                      group,
                      data.at(group).file,
                      data.at(group).desc,
                      data.at(group).array_depth > 0 or data.at(group).map_type,
                      data.at(group).value_type,
                      index);
    index++;
  }

  os << "\n[[nodiscard]] bool valid_wsg(std::string_view);\n";
}

void implement_docs(std::ostream& os) {
  std::println(os, "#include \"auto_wsg.h\"\n");

  for (auto& group : groups()) {
    std::println(os,
                 R"(std::string_view WorkspaceGroupInfo<{0}>::desc() {{
  return R"--({1})--"sv;
}}
)",
                 group,
                 data.at(group).desc);
  }
}

void auto_workspace(std::ostream& os) {
  os << R"--(//! auto-generated by make_auto_wsg.cpp

#include "workspace_agenda_class.h"
#include "workspace_method_class.h"

#include "workspace_class.h"

)--";

  for (auto& group : groups()) {
    os << std::format(R"(
template<> std::shared_ptr<{0}> Workspace::share_or<{0}>(const std::string& name) {{
  if (auto ptr = wsv.find(name); ptr not_eq wsv.end()) {{
    return ptr->second.template share<{0}>();
  }}

  Wsv out = {0}{{}};

  set(name, out);
  return out.share_unsafe<{0}>();
}}
template <> {0}& Workspace::get_or<{0}>(const std::string& name) {{
  return *share_or<{0}>(name);
}}
template <> {0}& Workspace::get<{0}>(const std::string& name) const try {{
  return wsv.at(name).get<{0}>();
}} catch (std::out_of_range&) {{
  throw std::runtime_error(std::format("Undefined workspace variable \"{{0}}\"", name));
}} catch (std::exception& e) {{
  throw std::runtime_error(std::format("Error getting workspace variable \"{{0}}\":\n{{1}}", name, std::string_view(e.what())));
}}
)",
                      group);
  }
}

void static_assert_for_vector_and_map(std::ostream& os) {
  os << R"--(
template <typename T>
concept has_value_type = requires { typename T::value_type; };

template <typename T>
concept value_type_is_wsg = QualifiedWorkspaceGroup<typename T::value_type>;

template <typename T>
concept mapped_type_is_wsg = QualifiedWorkspaceGroup<typename T::mapped_type>;

template <typename T>
concept python_requires_map_and_vector_subtype_are_groups =
    value_type_is_wsg<T> or (mapped_type_is_wsg<T>) or not has_value_type<T> or
    std::same_as<T, String>;

template <typename T>
concept internally_consistent =
      (value_type_is_wsg<T> or mapped_type_is_wsg<T>) or
   not WorkspaceGroupInfo<T>::map_or_vector;

)--";

  for (auto&& group : groups()) {
    os << std::format(R"(
static_assert(internally_consistent<{0}>,
     R"-x-("
This fails one of the following:
  1) It has either a value_type or a mapped_type templated type that is not a WSG (e.g., Array<NotWSG>)
")-x-");
)",
                      group);
  }
}

void agenda_operators() {
  const auto& wsv = internal_workspace_variables();
  const auto& wsa = internal_workspace_agendas();

  std::ofstream h("auto_agenda_operators.h");
  std::ofstream cpp("auto_agenda_operators.cpp");

  std::print(h, R"(#pragma once

)");

  std::print(cpp, R"(#include "auto_wsg.h"

#include <workspace_agenda_creator.h>
#include <time_report.h>
)");

  std::string errors{};

  for (auto& [name, ag] : wsa) {
    std::print(h,
               R"(
using {0}Operator
   = CustomOperator<std::tuple<)",
               name);

    std::string_view sep = "";
    for (auto& var : ag.output) {
      std::print(h, "{}{}", std::exchange(sep, ", "), wsv.at(var).type);
    }

    h << '>';

    for (auto& var : ag.input) {
      std::print(h, ", const {}&", wsv.at(var).type);
    }

    h << ">;\n";

    const std::string spaces(5 + name.size() + 8 + 8, ' ');

    cpp << "\nvoid " << name << "ExecuteOperator(";

    sep = "";
    for (auto& v : ag.output) {
      cpp << std::exchange(sep, ",\n" + spaces) << wsv.at(v).type << "& " << v;
    }

    for (auto& v : ag.input) {
      if (not std::ranges::contains(ag.output, v)) {
        cpp << ",\n" << spaces << "const " << wsv.at(v).type << "& " << v;
      }
    }

    cpp << ",\n"
        << spaces << "const " << name << "Operator& " << name
        << "_operator) try {\n  ARTS_TIME_REPORT\n\n";

    cpp << "  auto _tup = " << name << "_operator(";
    sep = "";
    for (auto& v : ag.input) {
      if (not std::ranges::contains(ag.output, v)) {
        cpp << std::exchange(sep, ", ") << v;
      }
    }
    cpp << ");\n";

    for (std::size_t i = 0; i < ag.output.size(); ++i) {
      cpp << "  " << ag.output[i] << " = std::get<" << i << ">(_tup);\n";
    }
    cpp << "}  ARTS_METHOD_ERROR_CATCH\n";

    std::print(cpp,
               R"(
void {0}SetOperator(Agenda& {0}, const {0}Operator& {0}_operator) {{
  ARTS_TIME_REPORT

  AgendaCreator agenda("{0}");
  agenda.add("{0}ExecuteOperator",
             SetWsv{{"{0}_operator", {0}_operator}});
  {0} = std::move(agenda).finalize(false);
}}
)",
               name);

    std::print(cpp,
               R"(
void xml_read_from_stream(std::istream&, {0}Operator&, bifstream*) {{throw std::runtime_error("Cannot read {0}Operator");}}
void xml_write_to_stream(std::ostream&, const {0}Operator&, bofstream*, const String&) {{throw std::runtime_error("Cannot save {0}Operator");}}
)",
               name);
  }

  if (not errors.empty()) {
    std::cerr << "Please add the following to workspace_groups.cpp:\n\n"
              << errors << '\n';
  }
}

constexpr std::string_view Name = "Wsv";

void wsv_header(std::ostream& os) {
  std::println(os,
               R"-x-(#pragma once

//! auto-generated file, edits do not persist

#include "auto_wsg.h"

class {0} {{
  std::shared_ptr<void> data;  // A shared_ptr custom variant
  std::size_t index;           // The index of the variant

  struct our_little_secret {{}};
  {0}(our_little_secret) : data(nullptr), index(-1) {{}}

public:

  std::size_t value_index() const noexcept {{
    return index;
  }}

  //! Default constructor, creates an Any
  {0}() : {0}{{std::shared_ptr<Any>(new Any{{}})}} {{}}

  {0}({0}&&) noexcept = default;
  {0}& operator=({0}&&) noexcept = default;

  //! We must be able to make a {0} from any of the allowed workspace groups
  template <WorkspaceGroup T>
  {0}(std::shared_ptr<T>&& x) noexcept :
    data{{std::move(x)}},
    index{{WorkspaceGroupInfo<T>::index}} {{}}

  //! We must be able to take over the data of a workspace group
  template <WorkspaceGroup T>
  {0}(T&& x) noexcept : {0}(std::shared_ptr<T>(new T{{std::move(x)}})) {{}}

  //! We must have a sneaky share constructor (note: this is unsafe)
  template <WorkspaceGroup T>
  {0}(T* x) noexcept : {0}(std::shared_ptr<T>(x, [](void*) {{}})) {{}}

  //! We must be able to copy workspace groups into the variant
  template <WorkspaceGroup T>
  {0}(const T& x) : {0}(std::shared_ptr<T>(new T{{ x }})) {{}}

  {0}& operator=(const {0}& x) {{ return *this  = {0}(x); }}

  [[nodiscard]] bool holds_same(const {0}& x) const noexcept {{
    return index == x.index;
  }}

  template <WorkspaceGroup T>
  [[nodiscard]] bool holds() const noexcept  {{
    return index == WorkspaceGroupInfo<T>::index;
  }}

  //! Unsafely share into the variant (this may segfault)
  template <WorkspaceGroup T>
  [[nodiscard]] std::shared_ptr<T> share_unsafe() const {{
    assert(holds<T>());
    return std::static_pointer_cast<T>(data);
  }}

  //! Safely share into the variant (this may throw)
  template <WorkspaceGroup T> [[nodiscard]] std::shared_ptr<T> share() const {{
    if (not holds<T>())
      throw std::runtime_error(std::format(R"(Casting "{{}}" to "{{}}")",
                                           WorkspaceGroupInfo<T>::name,
                                           type_name()));
    return share_unsafe<T>();
  }}

  //! Unsafely reference into the variant (this may segfault)
  template <WorkspaceGroup T> [[nodiscard]] T& get_unsafe() const {{
    assert(holds<T>());
    return *static_cast<T*>(data.get());
  }}

  //! Safely reference into the variant (this may throw)
  template <WorkspaceGroup T> [[nodiscard]] T& get() const {{
    if (not holds<T>())
      throw std::runtime_error(std::format(R"(Casting "{{}}" to "{{}}")",
                                           WorkspaceGroupInfo<T>::name,
                                           type_name()));
    return get_unsafe<T>();
  }}

  {0}(const {0}&) = default;

  //! Get a {0} that holds the named type
  static {0} from_named_type(const std::string_view);

  //! Get the type name of the variant
  [[nodiscard]] std::string_view type_name() const;

  //! Get the type name of the variant
  [[nodiscard]] std::string vformat(std::string_view) const;

  [[nodiscard]] {0} shared() const {{ return *this; }}
  [[nodiscard]] {0} copied() const;

  std::ostream& write_to_stream(std::ostream&, bofstream*, const std::string&) const;

  std::istream& read_from_stream(std::istream&, bifstream*);
}};)-x-",
               Name);
}

void wsv_implement_copied(std::ostream& os) {
  std::println(os, "{0} {0}::copied() const {{\n  switch(index) {{", Name);

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(
        os,
        R"(    case {1}: return {2} {{ {0} {{ get_unsafe<{0}>() }} }}; break;)",
        grps[i],
        i,
        Name);
  }

  std::println(os, "  }}\n  throw std::logic_error(\"bad copy\");\n}}");
}

void wsv_implement_from_named_type(std::ostream& os) {
  std::println(
      os, "{0} {0}::from_named_type(const std::string_view x) {{", Name);

  for (auto& group : groups()) {
    std::println(os,
                 "  if (x == \"{0}\"sv) {{ return {1} {{ {0}{{}} }}; }}",
                 group,
                 Name);
  }

  std::println(
      os,
      "throw std::runtime_error(std::format(R\"(Unknown Workspace Group: \"{{0}}\")\", x));\n}}");
}

void wsv_implement_type_name(std::ostream& os) {
  std::println(os,
               "std::string_view {0}::type_name() const {{\n  switch(index) {{",
               Name);

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(os, R"(    case {1}: return "{0}"sv;)", grps[i], i);
  }

  std::println(os, "  }}\n  throw std::logic_error(\"bad type_name\");\n}}");
}

void implement_valid_wsg(std::ostream& os) {
  std::println(os, R"--(//! auto-generated by make_auto_wsg.cpp

#include <algorithm>
#include <array>
#include <string_view>

using namespace std::literals;

bool valid_wsg(std::string_view x) {{
  constexpr static std::array val {{)--");
  for (auto& group : groups()) {
    std::println(os, "    \"{0}\"sv,", group);
  }

  std::println(os, R"--(  }};
  return std::binary_search(val.begin(), val.end(), x);
}})--");
}

void wsv_implement_vformat(std::ostream& os) {
  std::println(
      os,
      "std::string {0}::vformat(std::string_view fmt) const {{\n  switch(index) {{",
      Name);

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(
        os,
        R"(    case {1}: return std::vformat(fmt, std::make_format_args(get_unsafe<{0}>()));)",
        grps[i],
        i);
  }

  std::println(os, "  }}  throw std::logic_error(\"bad vformat\");\n}}");
}

void wsv_implement_write_to_stream(std::ostream& os) {
  std::println(
      os,
      "std::ostream& {0}::write_to_stream(std::ostream& os, bofstream* pbofs, const std::string& s) const {{\n  switch(index) {{",
      Name);

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(
        os,
        R"(    case {1}: xml_write_to_stream(os, get_unsafe<{0}>(), pbofs, s); break;)",
        grps[i],
        i);
  }

  std::println(os, "  }}\n  return os;\n}}");
}

void wsv_implement_read_from_stream(std::ostream& os) {
  std::println(
      os,
      "std::istream& {0}::read_from_stream(std::istream& is, bifstream* pbifs) {{\n  switch(index) {{",
      Name);

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(
        os,
        R"(    case {1}: xml_read_from_stream(is, get_unsafe<{0}>(), pbifs); break;)",
        grps[i],
        i);
  }

  std::println(os, "  }}\n  return is;\n}}");
}

void wsv_implement_includes(std::ostream& os) {
  std::println(os,
               R"-x-(//! auto-generated includes, edits do not persist

#include <cassert>
#include <format>

#include "auto_wsv_value_wrapper.h"
#include "workspace_agenda_class.h"
#include "workspace_method_class.h"
)-x-");
}

int main() try {
  std::ofstream head("auto_wsg.h");
  std::ofstream impl1("auto_wsg_docs.cpp");
  std::ofstream impl2("auto_wsg_valid_wsg.cpp");
  header(head);
  implement_docs(impl1);
  implement_valid_wsg(impl2);

  std::ofstream ws_os("auto_workspace.cpp");
  auto_workspace(ws_os);
  static_assert_for_vector_and_map(ws_os);

  agenda_operators();

  std::ofstream wsv_header_file("auto_wsv_value_wrapper.h");
  std::ofstream wsv_impl_file1("auto_wsv_value_wrapper_copied.cpp");
  std::ofstream wsv_impl_file2("auto_wsv_value_wrapper_from_named_type.cpp");
  std::ofstream wsv_impl_file3("auto_wsv_value_wrapper_type_name.cpp");
  std::ofstream wsv_impl_file4("auto_wsv_value_wrapper_vformat.cpp");
  std::ofstream wsv_impl_file5("auto_wsv_value_wrapper_read_from_stream.cpp");
  std::ofstream wsv_impl_file6("auto_wsv_value_wrapper_write_to_stream.cpp");

  wsv_header(wsv_header_file);

  wsv_implement_includes(wsv_impl_file1);
  wsv_implement_includes(wsv_impl_file2);
  wsv_implement_includes(wsv_impl_file3);
  wsv_implement_includes(wsv_impl_file4);
  wsv_implement_includes(wsv_impl_file5);
  wsv_implement_includes(wsv_impl_file6);

  wsv_implement_copied(wsv_impl_file1);
  wsv_implement_from_named_type(wsv_impl_file2);
  wsv_implement_type_name(wsv_impl_file3);
  wsv_implement_vformat(wsv_impl_file4);
  wsv_implement_read_from_stream(wsv_impl_file5);
  wsv_implement_write_to_stream(wsv_impl_file6);
} catch (std::exception& e) {
  std::cerr << "Cannot create the automatic groups with error:\n\n"
            << e.what() << '\n';
  return 1;
}
