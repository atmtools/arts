#include <format_tags.h>

#include <algorithm>
#include <format>
#include <fstream>
#include <iostream>
#include <ranges>
#include <utility>
#include <vector>

#include "workspace_agendas.h"
#include "workspace_groups.h"
#include "workspace_variables.h"

using namespace std::literals;

namespace {
const auto& data = internal_workspace_groups();

std::vector<std::pair<std::string, std::vector<std::string>>> files() {
  std::vector<std::pair<std::string, std::vector<std::string>>> files;

  for (const auto& [group_name, group] : data) {
    auto ptr = std::find_if(files.begin(),
                            files.end(),
                            [f = group.file](auto& p) { return f == p.first; });
    if (ptr == files.end()) {
      files.emplace_back(group.file, std::vector<std::string>{group_name});
    } else {
      ptr->second.push_back(group_name);
    }
  }

  std::sort(files.begin(), files.end(), [](auto& a, auto& b) {
    return a.first < b.first;
  });

  for (auto& [file, groups] : files) {
    std::sort(groups.begin(), groups.end());
  }

  // auto_wsa_operators.h must be last as it is auto-generated and need all the other types:
  auto ptr = std::find_if(files.begin(), files.end(), [](auto& p) {
    return p.first == "auto_agenda_operators.h";
  });

  if (ptr == files.end())
    throw std::logic_error("Missing auto_agenda_operators.h");

  std::rotate(ptr, ptr + 1, files.end());

  return files;
}

std::vector<std::string> groups() {
  std::vector<std::string> groups;
  groups.reserve(data.size());

  for (const auto& [group_name, group] : data) {
    groups.push_back(group_name);
  }

  std::sort(groups.begin(), groups.end());

  return groups;
}

void header(std::ostream& os) {
  os << R"--(#pragma once

//! auto-generated by make_auto_wsg.cpp

#include <memory>
#include <iosfwd>

)--";

  for (const auto& [file, groups] : files()) {
    os << "// ";
    for (const auto& group : groups) {
      os << group << ", ";
    }
    os << std::format("\n#include <{0}>\n\n", file);
  }

  os << "template <typename T>\nconcept WorkspaceGroup = false";
  for (auto& group : groups()) {
    os << std::format("\n  || std::is_same_v<T, {0}>", group);
  }
  os << "\n;\n\n"
        "template <typename T>\nconcept QualifiedWorkspaceGroup "
        "= WorkspaceGroup<std::remove_cvref_t<T>>;\n\n";

  os << R"(
template <typename T>
concept WorkspaceGroupIsDefaultConstructible = requires(T) {
  T{};
};

template <typename T>
concept WorkspaceGroupIsCopyable = requires(T a) {
  T{a};
};
)";

  os << '\n';

  os << R"(
template <typename T> struct WorkspaceGroupInfo {
  static constexpr std::string_view name = "<Unknown>";
  static constexpr std::string_view file = "<Unknown>";
  static std::string_view desc();
  static constexpr bool map_or_vector = false;
  static constexpr bool value_type = false;
};

)";

  std::size_t index = 0;
  for (auto& group : groups()) {
    os << std::format(R"(
template <> struct WorkspaceGroupInfo<{0}> {{
  static constexpr std::string_view name = "{0}";
  static constexpr std::string_view file = "{1}";
  static constexpr std::size_t index     =  {5};
  static constexpr bool map_or_vector     = {3};
  static constexpr bool value_type        = {4};
  static std::string_view desc();
}};
)",
                      group,
                      data.at(group).file,
                      data.at(group).desc,
                      data.at(group).array_depth > 0 or data.at(group).map_type,
                      data.at(group).value_type,
                      index);
    index++;
  }

  os << "\n[[nodiscard]] bool valid_wsg(std::string_view);\n";
}

void implement_docs(std::ostream& os) {
  std::println(os, "#include \"auto_wsg.h\"\n");

  for (auto& group : groups()) {
    std::println(os,
                 R"(std::string_view WorkspaceGroupInfo<{0}>::desc() {{
  return R"--({1})--"sv;
}}
)",
                 group,
                 data.at(group).desc);
  }
}

void auto_workspace(std::ostream& os) {
  os << R"--(//! auto-generated by make_auto_wsg.cpp

#include "workspace_agenda_class.h"
#include "workspace_method_class.h"

#include "workspace_class.h"

)--";

  for (auto& group : groups()) {
    os << std::format(R"(
template<> std::shared_ptr<{0}> Workspace::share_or<{0}>(const std::string& name) {{
  if (auto ptr = wsv.find(name); ptr not_eq wsv.end()) {{
    return ptr->second.template share<{0}>();
  }}

  Wsv out = {0}{{}};

  set(name, out);
  return out.share_unsafe<{0}>();
}}
template <> {0}& Workspace::get_or<{0}>(const std::string& name) {{
  return *share_or<{0}>(name);
}}
template <> {0}& Workspace::get<{0}>(const std::string& name) const try {{
  return wsv.at(name).get<{0}>();
}} catch (std::out_of_range&) {{
  throw std::runtime_error(std::format("Undefined workspace variable \"{{0}}\"", name));
}} catch (std::exception& e) {{
  throw std::runtime_error(std::format("Error getting workspace variable \"{{0}}\":\n{{1}}", name, std::string_view(e.what())));
}}
)",
                      group);
  }
}

void agenda_operators() {
  const auto& wsv = internal_workspace_variables();
  const auto& wsa = internal_workspace_agendas();

  const auto to_strings = std::ranges::to<std::vector<std::string>>();

  const auto agenda_types = std::views::transform([&wsv](const std::string& v) {
                              return wsv.at(v).type;
                            }) |
                            to_strings;

  const auto cref_agenda_types =
      std::views::transform([&wsv](const std::string& v) {
        return "const " + wsv.at(v).type + "&";
      }) |
      to_strings;

  const auto named_ref_agenda_types =
      std::views::transform(
          [&wsv](const std::string& v) { return wsv.at(v).type + "& " + v; }) |
      to_strings;

  const auto named_cref_agenda_types =
      std::views::transform([&wsv](const std::string& v) {
        return "const " + wsv.at(v).type + "& " + v;
      }) |
      to_strings;

  std::ofstream h("auto_agenda_operators.h");
  std::ofstream cpp("auto_agenda_operators.cpp");

  std::print(h, R"(#pragma once

)");

  std::print(cpp, R"(#include "auto_wsg.h"

#include <workspace_agenda_creator.h>
#include <time_report.h>

)");

  std::string errors{};

  for (auto& [name, ag] : wsa) {
    const auto remove_output =
        std::views::filter([&o = ag.output](const std::string& v) {
          return not std::ranges::contains(o, v);
        });
    const auto output_string =
        std::views::transform([&o = ag.output](const std::string& v) {
          return std::format(
              "{0} = std::get<{1}>(_tup);\n ",
              v,
              std::ranges::distance(o.begin(), std::ranges::find(o, v)));
        });

    std::println(h,
                 R"(
using {0}Operator
   = CustomOperator<std::tuple<{1:,}>,
                    {2:,}>;
)",
                 name,
                 ag.output | agenda_types,
                 ag.input | cref_agenda_types);

    const std::string spaces(5 + name.size() + 8 + 8, ' ');

    std::print(
        cpp,
        R"(void {0}ExecuteOperator({1:,}{3}{2:,}, const {0}Operator& {0}_operator) try {{
  ARTS_TIME_REPORT
  
  auto _tup = {0}_operator({4:,});
  {5} // end
}}  ARTS_METHOD_ERROR_CATCH

void {0}SetOperator(Agenda& {0}, const {0}Operator& {0}_operator) {{
  ARTS_TIME_REPORT

  AgendaCreator agenda("{0}");
  agenda.add("{0}ExecuteOperator",
             SetWsv{{"{0}_operator", {0}_operator}});
  {0} = std::move(agenda).finalize(false);
}}

)",
        name,
        ag.output | named_ref_agenda_types,
        ag.input | remove_output | named_cref_agenda_types,
        ag.output.empty() ? ""sv : ", "sv,
        ag.input,
        ag.output | output_string | to_strings);
  }

  if (not errors.empty()) {
    std::cerr << "Please add the following to workspace_groups.cpp:\n\n"
              << errors << '\n';
  }
}

void wsv_implement_copied(std::ostream& os) {
  std::println(os, "Wsv Wsv::copied() const {{\n  switch(index) {{");

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(
        os,
        R"(    case {1}: return Wsv {{ {0} {{ get_unsafe<{0}>() }} }}; break;)",
        grps[i],
        i);
  }

  std::println(os, "  }}\n  throw std::logic_error(\"bad copy\");\n}}");
}

void wsv_implement_from_named_type(std::ostream& os) {
  std::println(os, "Wsv Wsv::from_named_type(const std::string_view x) {{");

  for (auto& group : groups()) {
    std::println(
        os, "  if (x == \"{0}\"sv) {{ return Wsv {{ {0}{{}} }}; }}", group);
  }

  std::println(
      os,
      "throw std::runtime_error(std::format(R\"(Unknown Workspace Group: \"{{0}}\")\", x));\n}}");
}

void wsv_implement_type_name(std::ostream& os) {
  std::println(
      os, "std::string_view Wsv::type_name() const {{\n  switch(index) {{");

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(os, R"(    case {1}: return "{0}"sv;)", grps[i], i);
  }

  std::println(os, "  }}\n  throw std::logic_error(\"bad type_name\");\n}}");
}

void implement_valid_wsg(std::ostream& os) {
  std::println(os, R"--(//! auto-generated by make_auto_wsg.cpp

#include <algorithm>
#include <array>
#include <string_view>

using namespace std::literals;

bool valid_wsg(std::string_view x) {{
  constexpr static std::array val {{)--");
  for (auto& group : groups()) {
    std::println(os, "    \"{0}\"sv,", group);
  }

  std::println(os, R"--(  }};
  return std::binary_search(val.begin(), val.end(), x);
}})--");
}

void wsv_implement_vformat(std::ostream& os) {
  std::println(
      os,
      "std::string Wsv::vformat(std::string_view fmt) const {{\n  switch(index) {{");

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(
        os,
        R"(    case {1}: return std::vformat(fmt, std::make_format_args(get_unsafe<{0}>()));)",
        grps[i],
        i);
  }

  std::println(os, "  }}  throw std::logic_error(\"bad vformat\");\n}}");
}

void wsv_implement_write_to_stream(std::ostream& os) {
  std::println(
      os,
      "std::ostream& Wsv::write_to_stream(std::ostream& os, bofstream* pbofs, const std::string& s) const {{\n  switch(index) {{");

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(
        os,
        R"(    case {1}: xml_write_to_stream(os, get_unsafe<{0}>(), pbofs, s); break;)",
        grps[i],
        i);
  }

  std::println(os, "  }}\n  return os;\n}}");
}

void wsv_implement_read_from_stream(std::ostream& os) {
  std::println(
      os,
      "std::istream& Wsv::read_from_stream(std::istream& is, bifstream* pbifs) {{\n  switch(index) {{");

  auto grps = groups();

  for (size_t i = 0; i < grps.size(); ++i) {
    std::println(
        os,
        R"(    case {1}: xml_read_from_stream(is, get_unsafe<{0}>(), pbifs); break;)",
        grps[i],
        i);
  }

  std::println(os, "  }}\n  return is;\n}}");
}

void wsv_implement_includes(std::ostream& os) {
  std::println(os,
               R"-x-(//! auto-generated includes, edits do not persist

#include <cassert>
#include <format>

#include "wsv_value_wrapper.h"
#include "workspace_agenda_class.h"
#include "workspace_method_class.h"
)-x-");
}
}  // namespace

int main() try {
  std::ofstream head("auto_wsg.h");
  std::ofstream impl1("auto_wsg_docs.cpp");
  std::ofstream impl2("auto_wsg_valid_wsg.cpp");
  header(head);
  implement_docs(impl1);
  implement_valid_wsg(impl2);

  std::ofstream ws_os("auto_workspace.cpp");
  auto_workspace(ws_os);

  agenda_operators();

  // std::ofstream wsv_header_file("auto_wsv_value_wrapper.h");
  std::ofstream wsv_impl_file1("auto_wsv_value_wrapper_copied.cpp");
  std::ofstream wsv_impl_file2("auto_wsv_value_wrapper_from_named_type.cpp");
  std::ofstream wsv_impl_file3("auto_wsv_value_wrapper_type_name.cpp");
  std::ofstream wsv_impl_file4("auto_wsv_value_wrapper_vformat.cpp");
  std::ofstream wsv_impl_file5("auto_wsv_value_wrapper_read_from_stream.cpp");
  std::ofstream wsv_impl_file6("auto_wsv_value_wrapper_write_to_stream.cpp");

  // wsv_header(wsv_header_file);

  wsv_implement_includes(wsv_impl_file1);
  wsv_implement_includes(wsv_impl_file2);
  wsv_implement_includes(wsv_impl_file3);
  wsv_implement_includes(wsv_impl_file4);
  wsv_implement_includes(wsv_impl_file5);
  wsv_implement_includes(wsv_impl_file6);

  wsv_implement_copied(wsv_impl_file1);
  wsv_implement_from_named_type(wsv_impl_file2);
  wsv_implement_type_name(wsv_impl_file3);
  wsv_implement_vformat(wsv_impl_file4);
  wsv_implement_read_from_stream(wsv_impl_file5);
  wsv_implement_write_to_stream(wsv_impl_file6);
} catch (std::exception& e) {
  std::cerr << "Cannot create the automatic groups with error:\n\n"
            << e.what() << '\n';
  return 1;
}
