#include <algorithm>
#include <format>
#include <fstream>
#include <iostream>
#include <utility>
#include <vector>

#include "workspace_agendas.h"
#include "workspace_groups.h"
#include "workspace_variables.h"

const auto& data = internal_workspace_groups();

std::vector<std::pair<std::string, std::vector<std::string>>> files() {
  std::vector<std::pair<std::string, std::vector<std::string>>> files;

  for (const auto& [group_name, group] : data) {
    auto ptr = std::find_if(files.begin(),
                            files.end(),
                            [f = group.file](auto& p) { return f == p.first; });
    if (ptr == files.end()) {
      files.emplace_back(group.file, std::vector<std::string>{group_name});
    } else {
      ptr->second.push_back(group_name);
    }
  }

  std::sort(files.begin(), files.end(), [](auto& a, auto& b) {
    return a.first < b.first;
  });

  for (auto& [file, groups] : files) {
    std::sort(groups.begin(), groups.end());
  }

  // auto_wsa_operators.h must be last as it is auto-generated and need all the other types:
  auto ptr = std::find_if(files.begin(), files.end(), [](auto& p) {
    return p.first == "auto_agenda_operators.h";
  });

  if (ptr == files.end())
    throw std::logic_error("Missing auto_agenda_operators.h");

  std::rotate(ptr, ptr + 1, files.end());

  return files;
}

std::vector<std::string> groups() {
  std::vector<std::string> groups;
  groups.reserve(data.size());

  for (const auto& [group_name, group] : data) {
    groups.push_back(group_name);
  }

  std::sort(groups.begin(), groups.end());

  return groups;
}

void header(std::ostream& os) {
  os << R"--(#pragma once

//! auto-generated by make_auto_wsg.cpp

#include <memory>
#include <iosfwd>
#include <variant>

)--";

  for (const auto& [file, groups] : files()) {
    os << "// ";
    for (const auto& group : groups) {
      os << group << ", ";
    }
    os << std::format("\n#include <{0}>\n\n", file);
  }

  os << "template <typename T>\nconcept WorkspaceGroup = false";
  for (auto& group : groups()) {
    os << std::format("\n  || std::is_same_v<T, {0}>", group);
  }
  os << "\n;\n\n"
        "template <typename T>\nconcept QualifiedWorkspaceGroup "
        "= WorkspaceGroup<std::remove_cvref_t<T>>;\n\n";

  os << R"(
template <typename T>
concept WorkspaceGroupIsDefaultConstructible = requires(T) {
  T{};
};

template <typename T>
concept WorkspaceGroupIsCopyable = requires(T a) {
  T{a};
};
)";

  os << '\n';
  for (auto& group : groups()) {
    os << std::format(R"(
void xml_read_from_stream(std::istream &, {0}&, bifstream *);
void xml_write_to_stream(std::ostream &, const {0}&, bofstream *, const String &);
)",
                      group);
  }

  os << R"(
template <typename T> struct WorkspaceGroupInfo {
  static constexpr std::string_view name = "<Unknown>";
  static constexpr std::string_view file = "<Unknown>";
  static constexpr std::string_view desc = "<Unknown>";
  static constexpr bool map_or_vector = false;
  static constexpr bool value_type = false;
};

)";
  for (auto& group : groups()) {
    os << std::format(R"(
template <> struct WorkspaceGroupInfo<{0}> {{
  static constexpr std::string_view name = "{0}";
  static constexpr std::string_view file = "{1}";
  static constexpr std::string_view desc = R"--({2})--";
  static constexpr bool map_or_vector = {3};
  static constexpr bool value_type = {4};
}};
)",
                      group,
                      data.at(group).file,
                      data.at(group).desc,
                      data.at(group).array_depth > 0 or data.at(group).map_type,
                      data.at(group).value_type);
  }

  os << "using WsvValue = std::variant<";
  bool first = true;
  for (auto& group : groups()) {
    if (not first) os << ',';
    first = false;
    os << std::format("\n  std::shared_ptr<{0}>", group);
  }
  os << ">;\n\n";
  os << "[[nodiscard]] bool valid_wsg(const std::string_view&);\n";
}

void implementation_init(std::ostream& os) {
  os << R"--(//! auto-generated by make_auto_wsg.cpp

#include <typeinfo>

#include "auto_wsg.h"

#include "workspace_agenda_class.h"
#include "workspace_method_class.h"
#include "workspace_wsvwrapper.h"
#include "workspace_wsv.h"

)--";

  for (auto&& group : groups()) {
    os << std::format(R"-x-(
template <> Wsv::Wsv(std::shared_ptr<{0}>&& x)  noexcept : data(new WsvValueWrapper(std::move(x))) {{}}
template <> Wsv::Wsv({0}&& x)  noexcept : Wsv(std::make_shared<{0}>(std::forward<{0}>(x))) {{}}
template <> Wsv::Wsv(const {0}& x) : Wsv(std::make_shared<{0}>(x)) {{}}
template <> Wsv::Wsv({0}* x)  noexcept : Wsv(std::shared_ptr<{0}>(x, [](void*){{}})) {{}}
)-x-",
                      group);
  }
}

void implementation_share(std::ostream& os) {
  os << R"--(//! auto-generated by make_auto_wsg.cpp

#include <typeinfo>

#include "auto_wsg.h"

#include "workspace_agenda_class.h"
#include "workspace_method_class.h"
#include "workspace_wsvwrapper.h"

)--";

  os << R"(std::string_view Wsv::type_name() const {
  switch(index()) {)";

  std::size_t i = 0;
  for (auto& group : groups()) {
    os << std::format(R"(
    case {0}:
      static_assert(std::same_as<std::shared_ptr<{1}>,
                                 std::variant_alternative_t<{0}, WsvValue>>,
                                 "Wrong type {1}");
      return "{1}";)",
                      i,
                      group);
    i++;
  }
  os << R"--(  }

  return "Unknown"sv;
}

)--";

  os << "bool valid_wsg(const std::string_view& x) {\n  constexpr static std::array val {\n";
  for (auto& group : groups()) {
    os << std::format("    \"{0}\", \n", group);
  }

  os << R"--(  };
  return std::binary_search(val.begin(), val.end(), x);
}

Wsv Wsv::from_named_type(const std::string& type) {
)--";

  for (auto& group : groups()) {
    os << std::format("  if (type == \"{0}\") return {0}{{}};\n", group);
  }

  os << R"--( throw std::runtime_error(std::format("Unknown workspace group \"{}\"", type));
}

)--";

  for (auto& group : groups()) {
    os << std::format(R"-x-(
template <> bool Wsv::holds<{0}>() const {{
  return std::holds_alternative<std::shared_ptr<{0}>>(value());
}}
template <> const std::shared_ptr<{0}>& Wsv::share_unsafe<{0}>() const {{
  return *std::get_if<std::shared_ptr<{0}>>(data);
}}
template <> const std::shared_ptr<{0}>& Wsv::share<{0}>() const {{
  ARTS_USER_ERROR_IF(not holds<{0}>(),
    R"(Cannot use workspace variable of workspace group "{{}}" as "{0}")",
    type_name());

  return share_unsafe<{0}>();
}}
template <> {0}& Wsv::get_unsafe<{0}>() const {{
  return *share_unsafe<{0}>();
}}
template <> {0}& Wsv::get<{0}>() const {{
  return *share<{0}>();
}}
)-x-",
                      group);
  }

  // Static asserts
  for (auto& group : groups()) {
    os << std::format(R"-x-(
static_assert(WorkspaceGroupIsDefaultConstructible<{0}>, "Must be default constructible");
static_assert(WorkspaceGroupIsCopyable<{0}>, "Must be possible to copy");
static_assert(arts_formattable_or_value_type<{0}>, "Must be formattable according to ARTS rules");
)-x-",
                      group);
  }
}

void auto_workspace(std::ostream& os) {
  os << R"--(//! auto-generated by make_auto_wsg.cpp

#include "workspace_agenda_class.h"
#include "workspace_method_class.h"

#include "workspace_class.h"

)--";

  for (auto& group : groups()) {
    os << std::format(R"(
template<> std::shared_ptr<{0}> Workspace::share_or<{0}>(const std::string& name) {{
  if (auto ptr = wsv.find(name); ptr not_eq wsv.end()) {{
    return ptr->second.template share<{0}>();
  }}

  Wsv out = {0}{{}};

  set(name, out);
  return out.share_unsafe<{0}>();
}}
template <> {0}& Workspace::get_or<{0}>(const std::string& name) {{
  return *share_or<{0}>(name);
}}
template <> {0}& Workspace::get<{0}>(const std::string& name) const try {{
  return wsv.at(name).get<{0}>();
}} catch (std::out_of_range&) {{
  throw std::runtime_error(std::format("Undefined workspace variable \"{{0}}\"", name));
}} catch (std::exception& e) {{
  throw std::runtime_error(std::format("Error getting workspace variable \"{{0}}\":\n{{1}}", name, std::string_view(e.what())));
}}
)",
                      group);
  }
}

void static_assert_for_vector_and_map(std::ostream& os) {
  os << R"--(
template <typename T>
concept has_value_type = requires { typename T::value_type; };

template <typename T>
concept value_type_is_wsg = QualifiedWorkspaceGroup<typename T::value_type>;

template <typename T>
concept mapped_type_is_wsg = QualifiedWorkspaceGroup<typename T::mapped_type>;

template <typename T>
concept python_requires_map_and_vector_subtype_are_groups =
    value_type_is_wsg<T> or (mapped_type_is_wsg<T>) or not has_value_type<T> or
    std::same_as<T, String>;

template <typename T>
concept internally_consistent =
      (value_type_is_wsg<T> or mapped_type_is_wsg<T>) or
   not WorkspaceGroupInfo<T>::map_or_vector;

)--";

  for (auto&& group : groups()) {
    os << std::format(R"(
static_assert(internally_consistent<{0}>,
     R"-x-("
This fails one of the following:
  1) It has either a value_type or a mapped_type templated type that is not a WSG (e.g., Array<NotWSG>)
")-x-");
)",
                      group);
  }
}

void agenda_operators() {
  const auto& wsv = internal_workspace_variables();
  const auto& wsa = internal_workspace_agendas();

  std::ofstream h("auto_agenda_operators.h");
  std::ofstream cpp("auto_agenda_operators.cpp");

  std::print(h, R"(#pragma once

)");

  std::print(cpp, R"(#include "auto_wsg.h"

#include <workspace_agenda_creator.h>
#include <time_report.h>
)");

  std::string errors{};

  for (auto& [name, ag] : wsa) {
    std::print(h,
               R"(
using {0}Operator
   = CustomOperator<std::tuple<)",
               name);

    std::string_view sep = "";
    for (auto& var : ag.output) {
      std::print(h, "{}{}", std::exchange(sep, ", "), wsv.at(var).type);
    }

    h << '>';

    for (auto& var : ag.input) {
      std::print(h, ", const {}&", wsv.at(var).type);
    }

    h << ">;\n";

    const std::string spaces(5 + name.size() + 8 + 8, ' ');

    cpp << "\nvoid " << name << "ExecuteOperator(";

    sep = "";
    for (auto& v : ag.output) {
      cpp << std::exchange(sep, ",\n" + spaces) << wsv.at(v).type << "& " << v;
    }

    for (auto& v : ag.input) {
      if (not std::ranges::contains(ag.output, v)) {
        cpp << ",\n" << spaces << "const " << wsv.at(v).type << "& " << v;
      }
    }

    cpp << ",\n"
        << spaces << "const " << name << "Operator& " << name
        << "_operator) try {\n  ARTS_TIME_REPORT\n\n";

    cpp << "  auto _tup = " << name << "_operator(";
    sep = "";
    for (auto& v : ag.input) {
      if (not std::ranges::contains(ag.output, v)) {
        cpp << std::exchange(sep, ", ") << v;
      }
    }
    cpp << ");\n";

    for (std::size_t i = 0; i < ag.output.size(); ++i) {
      cpp << "  " << ag.output[i] << " = std::get<" << i << ">(_tup);\n";
    }
    cpp << "}  ARTS_METHOD_ERROR_CATCH\n";

    std::print(
        cpp,
        R"(
void {0}SetOperator(Agenda& {0}, const {0}Operator& {0}_operator) {{
  ARTS_TIME_REPORT

  AgendaCreator agenda("{0}");
  agenda.add("{0}ExecuteOperator",
             SetWsv{{"{0}_operator", {0}_operator}});
  {0} = std::move(agenda).finalize(false);
}}
)",
        name);

    std::print(cpp,
               R"(
void xml_read_from_stream(std::istream&, {0}Operator&, bifstream*) {{throw std::runtime_error("Cannot read {0}Operator");}}
void xml_write_to_stream(std::ostream&, const {0}Operator&, bofstream*, const String&) {{throw std::runtime_error("Cannot save {0}Operator");}}
)",
               name);
  }

  if (not errors.empty()) {
    std::cerr << "Please add the following to workspace_groups.cpp:\n\n"
              << errors << '\n';
  }
}

int main() try {
  std::ofstream head("auto_wsg.h");
  std::ofstream init("auto_wsg_init.cpp");
  std::ofstream share("auto_wsg_share.cpp");
  header(head);
  implementation_init(init);
  implementation_share(share);

  std::ofstream ws_os("auto_workspace.cpp");
  auto_workspace(ws_os);
  static_assert_for_vector_and_map(ws_os);

  agenda_operators();
} catch (std::exception& e) {
  std::cerr << "Cannot create the automatic groups with error:\n\n"
            << e.what() << '\n';
  return 1;
}
